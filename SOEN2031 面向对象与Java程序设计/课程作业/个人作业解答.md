# 个人作业解答

此部分为我个人对本课程作业的解答，仅供参考。

## 作业1

1. Java 2是第2版Java的意思吗？

    **答**：不是。Java 2通常指JDK1.2，在JDK1.1之后的Java版本都被认为是Java 2（尽管有这一说法，但事实上已经基本没人这么说了），而《Java 2实用教程》使用的Java版本是Java1.5（即Java 5），实际上已经非常过时了。Java的版本命名非常混乱，一直到Java 8都是按照JDK 1.1、1.2……1.8这样命名的，并且每个大版本更新都非常缓慢，然而到了2017年，Oracle突然宣布下一个JDK版本将直接被命名为JDK 9，并且以近乎九月一更的速度迅速迭代，2022年3月22日即将更新Java 18，目前最新的LTS版本是Java 17，但Java 8作为特殊的LTS版本支持年限将比Java 17更长。Oracle曾试图模仿JavaScript将版本号以年份命名，例如将下一个版本命名为Java 2022，然而疑似遭到许多人反对，不了了之。尽管Java已经更新到了Java 17，然而其实相比于Java 8并没有什么显著的语法层面更新（少数的几个变化是var的加入），并且Java 8是最后一个免费的Java版本，同时相比Java 6有了巨大更新（例如Stream API），这也是许多公司仍然使用Java 8的原因。尽管如此，Java的知名后端框架Spring宣布下一个版本的最低Java版本为Java 17，这或许能够促使许多公司升级Java 8。

2. 如果每种高级语言的作者都声称自己设计的语言比其他语言容易学，你觉得这会是真的吗？

    **答**：有趣的是，Java之父James Gosling曾在演讲中表示“Java远比其他语言易学”（当然，这是90年代的事情，现在这句话显然不成立了），一大原因是“Java是完全面向对象的”，不过这一点如今被许多人质疑，例如Java中基本类型的存在与类型擦除等问题，并且面向对象如今被认为不是一个非常完美的解决问题的方式，而Java完全面向对象的设计造成了严重的语法冗余问题，并且需要层层抛出错误的问题导致其错误处理非常麻烦。我个人认为Java甚至还不如Smalltalk更“面向对象”，虽然它似乎在面向对象上更加“纯粹”，但也因此牺牲了自由。

    从其他语言的角度来说，其实像是C也很易学。Brian W. Kernighan曾表示C并不是一门精心设计的好语言，“它因为足够烂而流行”，这得归功于C简洁的语法。如果要学会C的语法，其实甚至比Python还要简单，因为它仅有有限的那么几个函数与语句，因此说“C语言非常易学”似乎也并没有什么问题。甚至可以说LISP也很易学——要学会Scheme的语法甚至花不了两个小时，连一个Scheme解释器都可以用几百行代码轻松编写。但这并不意味着它们真正易学，C的指针、弱类型、垃圾回收，LISP手写抽象语法树的奇妙语法，都意味着它们写出来的程序并不易读，要深入学起来也会非常抽象，可维护性也不高。Paul Graham是LISP的狂信徒，他应当是具有良好的代码编写习惯的，但当他把Viaweb卖给Yahoo之后，Yahoo竟找不出一个人能够维护他写的代码。这足见“简洁”的语言不一定具有高可维护性，从这个角度来说，“语法简单”并不意味着易学。

    Python和Ruby作为为了高速编写脚本而生的动态语言，连类型定义都不需要，而且自然带有垃圾回收，也很少需要考虑引用的问题，似乎很“易学”。Ruby甚至能写出2.days.ago这样宛若英文作文的代码，看起来真是太易学了，松本行弘也表示他的目的是“make programming fun”。但这些将“像写作文一样编程”贯彻到极致的语言真的易学吗？似乎也未必。不提Ruby多到宛若灾难的语法糖，仅就Python而言，仅仅要将其各类基本语法搞明白就不那么容易，with/iterator/generator……要深入学下去也不见得就很简单。更何况这些语言为了实现真正的“英文作文编程”还会大量运用元编程技巧，Ruby元编程甚至可以写一本四百多页的书（参见《Ruby元编程》一书，这还是Ruby 2.x版本），深入到这个层面上来说无疑就变得有些晦涩了。而且动态也有动态的问题，对于大规模代码重构来说，动态类型有时候更像是一种灾难。Python甚至连词法作用域也没有，在有些情况下，这反而会造成困惑。Python和Ruby容易入门，但其繁杂性导致深入学习却并不容易，从这个角度来看，它们也不是很“易学”。

    那么JavaScript呢？前端似乎人人都可以上，对此一无所知的新人好像也能报三个月培训班快速入门。然而JavaScript事实上有着与Java相似的语法和完全不同的内核，例如经典的Prototype-based Inheritance，这导致从Java/C++转来的程序员要理解这些东西反而会很困难。况且在TC39委员会近些年给JavaScript带来的越来越多的特性看来，其复杂性还会进一步提高，在管道操作符（“|>”操作符，来源是F#与Hack）加入后，恐怕阅读起来也不会很方便。JavaScript是一个典型的受到历史遗留问题迫害的语言，这也反映了如果某一语言被广泛应用并且长时间不被取代，其语法糟粕必定会随着时间的增长而不断增加，从这个角度来看，不存在永远“易学”的语言。

    近些年兴起的Go倒是相对比较“易学”，其简洁到堪称简陋的语法甚至被认为是一种时代倒退，但这种简洁性确实使得Go的入门非常简单，那本《Go程序设计语言》也远比《Java核心编程》薄上太多，即使最新版的《learning Go》（中文版还没出）也就三百多页的样子。然而就和C一样，简单的语法并不意味着事实上的“易学”，简单的语法意味着复杂一些的功能需要使用更大的代码量实现，Go在前几天正式加入泛型之前甚至需要手写一大堆Interface，从这个角度来看，恐怕也不算“易学”。

    语法简洁与高效编程似乎有着不可调和的矛盾，高效编程或者“Make programming fun”必定意味着语法复杂度的增加，这自然也意味着学习成本的增加，语法简洁又必定意味着实现某一功能所需的代码量增加，而且多数情况下意味着抽象程度的增加。同时，越不需要考虑底层问题的语言其运行速度也就越慢，因为解释器/编译器为了理解语言的复杂性与较多的语法糖必然会牺牲很大一部分运行性能，一个典型例子是Java仅仅加入了垃圾回收就使得其代码比C++慢了十倍不止（一开始是这样，近些年Java的性能已经优化的很好了），而Python能慢百倍不止。一个折衷的办法是编译到其他语言，例如JavaScript，比如Scala就有过这方面的尝试，但这只是把运行速度的降低转移到了编译速度的降低上而已。“易学”在不同方面甚至是矛盾的，真正“易学”的语言永远不可能出现。


## 作业2

1.  电视剧“北京人在纽约”的开头有这么一句台词：“如果你爱他，就把他送到纽约去，因为那里是天堂；如果你恨他，就把他送到纽约去，因为那里是地狱。” 

    如果将外出打拼的人换成程序员的话，完全有理由可以把这句台词改成：“如果你爱他，就让他使用指针吧，因为那里是天堂；如果你恨他，就让他使用指针吧，因为那里是地狱。” 刚开始出现的高级语言没有指针，后来出现的高级语言有了指针，再后来出现的 C#，Java，Python 等又没了指针。难道C#，Java，Python 等真的就没了指针？为什么要这样做呢？

    **答**：在C#、Java、Python中，指针只是改了个名字，叫做引用而已。例如下面这一段Python代码：

    ```python
    >>> def unique_integer():
    ...     count = [0]
    ...     def _():
    ...         count[0] += 1
    ...         return count[0]
    ...     return _
    ... 
    >>> unique_integer = unique_integer()
    >>> unique_integer()
    0
    >>> unique_integer()
    1
    >>> unique_integer()
    2
    ```

    即使没有指针，Python代码仍然能够产生副作用（Side Effects），甚至能够像上面演示的一样使用闭包。如果要产生副作用，就必然需要通过指针（或者引用）实现，这无法避免，指针从未真正消失，只是程序员不用去管底层取址问题与垃圾回收了而已。

    另外，需要注意的是，Java/Python等语言中的“引用”与C++中的“引用”完全不是一回事。C++中的引用只是“变量别名”，而Java/Python等语言中的引用是直接指向对象的。事实上，在Java刚刚出现时，很多由C++转来的程序员经常把这两个概念搞混，因此Bruce Eckel曾在他的著作《Java编程思想》中将Java中的“引用”称作“句柄(handle)”，这就是我们如今常说的“窗口句柄”“文件句柄”的由来（老实说，这中文翻译确实非常糟糕）。不过后来，在Java以及一众抛弃指针的语言越来越流行后，再称呼“引用”为“指针”已经没有必要了，而且也很少有人会把C++和Java中的引用搞混了，因此又按照Java官方的称呼重新将“句柄”改回了“引用”。

    不过在纯粹的函数式编程语言，例如LISP和Haskell中，确实通过完全不加入副作用而完全抛弃了指针的概念，它们通过Monad（或者叫Functor）来实现副作用，不过这就是题外话了。
    
    其实在最初的Fortran中，同样有指针，只是和后来的语言比较相似，叫做引用而已。命令式（Imperative）语言不可能没有副作用，自然也避免不了指针/引用。C独特的创新是加入了指针变量，使底层操作直接暴露给了程序员，这不可避免会造成内存泄漏的问题（比如所谓的“野指针”），但也使得它非常适合底层操作，例如编写操作系统和浏览器（不过目前看来Rust成为了新一代的更好选择）。在底层开发方面（例如操作系统和嵌入式开发），C的作用毫无疑问仍然是无可替代的。


## 作业3
1. 某年，张三设计出的高级语言甲横空出世，结果大获全胜，风靡IT 界。斗转星移，甲越来越显得力不从心，虽经多次改良，毕竟大势已去。李四见状，遂推出高级语言乙。在各个方面，乙不是比甲强大就是和甲打平。请问甲会立马出局吗？为什么？

    **答**：不会。JavaScript设计得那么烂也还没被淘汰呢，反而越来越火了，Rust看起来处处比C++好也远远不能取代C++的地位。时间给语言带来了历史包袱的同时也带来了庞大的生态，Java现在看来绝不是什么优秀的语言，但它庞大的生态令其他语言望而生畏，宣称要取代Java的语言最终只能融入Java生态成为Java的一部分，例如Kotlin和Scala都是跑在JVM上的。C++连个包管理器都没有，CMake堪称反人类，但在音视频和高性能服务器领域仍然鲜有对手。

    “烂语言比好语言更容易流行”不是一句假话。Rust有非常多“Modern”的设计，但其学习曲线的陡峭注定了Rust不会真正流行，甚至能够取代C++都很难说（我个人认为概率很小），毕竟不是每个人都愿意与编译器斗智斗勇的。甚至连几乎全面优于Python 2的Python 3都经过了十多年才被广泛接受，语言的惯性是非常难以克服的。相比于接受更好的新事物，人们往往更乐于使用自己熟悉的旧技术，这是无法避免的。设计优秀的语言中往往有很多优秀的设计并不为大多数人理解，在实际用到这些优秀特性之前，那些优秀的特性反而像是障碍。优秀的设计有时候意味着更多的限制，TypeScript的类型系统很优秀也很安全，但相比于编写复杂的类型系统，人们更乐意写一个“any”了事，大多数人也只是把TypeScript当作“更适合IDE静态类型检查”的JavaScript而已，目的不是为了提供类型安全，而是为了方便自己写代码的时候不断摁回车。

    另外，其实我也很怀疑“在各个方面，不是更强大就是打平”的语言是否存在。Java也不敢说比Smalltalk更好，Racket也不敢说比Scheme更好，甚至硬要说Python 3都不一定比Python 2更好，要不然为什么服务器还是在大量使用Python 2呢。任何一门新语言推出的目的都不应该是“取代”之前某一语言的生态位，而是发掘新的生态位，并在一定程度上代替之前的某门语言。

2. 下列程序标注的【代码1】和【代码2】的输出结果是什么？

    ```java
    public class E {
        public static void main (String[] args) {
            long[] a = {1, 2, 3, 4};
            long[] b = {100, 200, 300, 400, 500};
            b = a;
            System.out.println("数组b的长度: " + b.length); // 【代码1】
            System.out.println("b[0] = " + b[0]);           // 【代码2】
        }
    }
    ```

    **结果**：

    ```
    4
    1
    ```

3. 下列程序标注的【代码1】和【代码2】的输出结果是什么？

    ```java
    public class E {
        public static void main (String[] args) {
            int[] a = {10, 20, 30, 40};
            int[][] b = {{1, 2}, {4, 5, 6, 7}};
            b[0] = a;
            b[0][1] = b[1][3];
            System.out.println(b[0][3]); // 【代码1】
            System.out.println(a[1]);    // 【代码2】
        }
    }
    ```

    **结果**：
    
    ```
    40
    7
    ```


## 作业4
1.  某老师给同学出了一道上机题：求1+1/1!+1/2!+1/3!+...+1/20!的近似值。

    当同学甲看到同学乙编写的程序后，两人争了起来。

    甲：你从右往左求和，别扭不说，还增加计算量。

    乙：这类问题要是从左往右求和，结果可能会有点问题。

    甲：有点问题？难道你连小时候学的加法结合律都记不得了？

    请问到底谁对呢？为什么？

    **答**：考虑到IEEE754的浮点数表示方式，从右往左求和（即从小到大求和）舍入误差更小，得到的值更准。

2. 下列程序的输出结果是什么？

    ```java
    public class E {
        public static void main (String[] args) {
            char x = '你', y = 'e', z = '吃';
            if (x > 'A') {
                y = '苹';
                z = '果';
            }
            else
                y = '酸';
            z = '甜';
            System.out.println(x + ", " + y + ", " + z);
        }
    }
    ```

    **结果**：

    ```
    你, 苹, 甜
    ```

    *注：正常人应该不会这样写代码。

3. 下列程序的输出结果是什么？

    ```java
    public class E {
        public static void main (String[] args) {
            char c = '\0';
            for (int i = 1; i <= 4; i++) {
                switch (i) {
                    case 1:
                        c = 'J';
                        System.out.print(c);
                    case 2:
                        c = 'e';
                        System.out.print(c);
                        break;
                    case 3:
                        c = 'p';
                        System.out.print(c);
                    default:
                        System.out.print("好");
                }
            }
        }
    }
    ```

    **结果**：

    ```
    Jeep好好
    ```

    *注：在正常使用中，Switch的Fall Through特性应当被尽量少地使用。

4. 下列程序的输出结果是什么？

    ```java
    public class test {
        public static void main (String[] args) {
            int x = 1, y = 6;
            while (y-- > 0) {
                x--;
            }
            System.out.print("x=" + x + ", y=" + y);
        }
    }
    ```

    **结果**：

    ```
    x=-5, y=-1
    ```
    
    *注：个人认为++与—运算符不是一个好的语言设计，这两个设计有时候相比起方便带来更多麻烦。按照函数式编程思想，任何没有必要的副作用都应该被尽可能避免。


## 作业5
1. 某同学在学习了 Python 和 Java 语言程序设计课程后，对结果为整型和实型的两种除法的表达方式颇感兴趣，于是又找来一些其他语言的资料加以对比，并尝试设计一种有别于前人的表达方式。如果让你来参与，你会怎样设计呢？

    **答**：按照我个人的想法，Python使用`/`表示正常的除法，使用`//`表示整除非常符合正常逻辑。C-Style语言中整型相除默认向下取整才是反人类的。在计算机性能越来越好的今天，已经没有任何必要使用C-Style语言中的除法形式，并且现代不过多涉及底层运算的高级语言都应当尽量不再区分整型和浮点型，Ruby就做的很好，Python虽然实质上区分整型和浮点型但它们之间的运算不存在任何障碍（这主要涉及Python的consistent-with机制，这是结构化类型/鸭子类型带来的），做的也非常好。

    如果我需要设计一门新语言，我应当会考虑使用`/`表示常规除法，并使用某个关键字比如`aliquot`表示整除运算，例如`3 aliquot 2 == 1`，这主要是因为我会考虑沿用C-Style编程风格，将`//`用作注释。

    事实上我近些日子一直在考虑设计一门全新的语言，主要通过编译到JavaScript运行。我试图将这门语言命名为`Rhyme`。其中关于运算符我有一些很不同的想法。在我看来运算符应当成为一种单独的类型，并独立于函数。任何运算符应当通过在两边加上空格调用（取负运算符除外，它必须不加空格调用），这利于自定义运算符与运算符重载。

    另外，我一直感到位运算符占用了本就很宝贵的几个符号，又往往很少被人使用，应当被取消，改用特殊方法调用这些运算符。

    例如，下面是`Rhyme`通过自定义运算符实现DSL（领域专用语言）的一个例子。这里实现的是管道运算符`|>`：

    ```rhyme
    Object.prototype.|> = op <T, U>(f: T => U) -> U {
      return f(this)
    }
    1 |> v => v + 1 |> v => v ^ 2 // => 4
    ```
    
    下面演示Rhyme中的运算符重载：
    
    ```rhyme
    let Vector2D = class (restricted x: num, restricted y: num) {
      const private length = (x ^ 2 + y ^ 2) ^ 0.5
      fn toString () { return 'Vector2D(' + self.x + ', ' + self.y + ')' }
      op - () { return cls(-self.x, -self.y) }
      op - (rhs: cls) { return cls(self.x - rhs.x, self.y - rhs.y) }
      op + (rhs: cls) { return cls(self.x + rhs.x, self.y + rhs.y) }
      op * (rhs: cls) { return self.x * cls.x + self.y * cls.y }
    }
    
    let vec1 = Vector2D(1, 2)
    let vec2 = Vector2D(3, 4)
    - vec1 // !TypeError
    -vec1 // => Vector2D(-1, -2)
    vec1-vec2 // !TypeError
    vec1 - vec2 // => Vector2D(-2, -2)
    vec1 + vec2 // => Vector2D(4, 6)
    vec1 * vec2 // => 11
    ```
    
    通过合理的运算符重载，Rhyme可以写出英语作文一般的代码：
    
    ```rhyme
    // 定义符号"ago"
    // 符号也是基本数据类型之一
    // 符号永远不会相同，类似JavaScript。此外，这里也借鉴了LISP的思想
    const ago = symbol 'ago'
    // 在基本类型number上定义运算符“days”
    // 当接收一个参数时，运算符为双目运算符，自身（this）为左值，参数为右值
    // 当不接收参数时，运算符为单目运算符，右值为自身
    // 运算符不接受可变参数，也不接受除0和1之外的参数
    // 自定义运算符的优先级永远最低，不可更改
    // 这里定义的是双目运算符
    Number.prototype.days = op (rhs: symbol) {
      if rhs.value != 'ago' {
        throw TypeError('operator "days" must be called with  "ago"')
      }
      return datetime.now() - this * 24 * 60 * 60 * 1000
    }
    // 当前时间为2022-03-19 01:15:52
    const t = 2 days ago
    print(t) // => 2022-03-17 01:15:52
    ```
    
    我一直认为通过圆括号调用函数是多余的，为什么不能通过空格直接调用呢？因此在Rhyme中，只要在定义函数时加上`@operator`装饰器，就可以让它像运算符一样使用（仅限于单参数和双参数函数，并且不支持可变参数）：
    
    ```rhyme
    const add = @operator fn add (l: num, r: num) -> num {
      return l + r
    }
    add(1, 2) // => 3
    1 add 2   // => 3
    ```
    
    运算符理应被赋予更高的地位，运算符重载也理应得到更广泛的应用。

2. 下面程序段的功能是什么？
   
    ```java
    int n, x = 0, y = 1;
    Scanner reader = new Scanner(System.in);
    do {
        System.out.println("n(n>=0)=?");
        n = reader.nextInt();
    } while (n < 0);
    reader.close();
    while (y <= n) {
        x++;
        y += 2 * x + 1;
    }
    System.out.println(x);
    ```
    
    **解析**：首先不断读取输入值（整型）直到大于等于$$0$$，将其赋值给$$n$$。然后找到满足$$2x+1≤n$$的最大$$x$$值，并输出$$x+1$$。相当于$$(x+1)//2$$。


## 作业6
1. 同学甲和乙之前学了 Python 语言程序设计课程，现在正在学 Java 语言程序设计课程。甲发现 Java 语言里有执行效率极高的自增和自减运算符，而 Python 语言里竟然没有，于是问乙个中缘由，但乙也弄不明白。你能给他们解释一下吗？

    **答**：目前主流的观点是自增和自减运算符并不是一个很好的设计，它带来的麻烦往往多于好处。当前有不少新语言设计时不再提供自增和自减运算符，即使试图替代C++的Rust也没有提供自增自减运算符。

    其中原因有很多。首先，自增自减运算符几乎在所有情况下都会降低代码可读性，并且容易导致潜在的BUG。目前的一大共识是编程语言应当尽可能减少副作用，尽量让语句完成一切有副作用的操作（例如赋值语句），这一思想通常被认为来自于函数式编程。然而自增自减运算符反其道而行之，居然运算符也能包含副作用，这毫无疑问会造成语法上的不一致。另外，自增自减运算符其实本质上也是赋值操作，但在代码里并不十分明显，很容易被人忽略它有副作用的事实，导致潜在的BUG。

    诚然，自增自减运算符能够一定程度上简化代码，但简化代码不一定是件好事，尤其是这需要以降低代码可读性为代价，那就更加得不偿失了。我个人并不喜欢这一设计，并且尽可能避免使用它。我认为在C-like编程语言中自增自减运算符唯一的使用场景就是传统for循环，因为这已经成为一个惯例，并且放在这里不会降低代码可读性。然而在几乎所有语言都支持for-each循环的今天（即使Java也早就加入了），使用传统for循环的场景已经大大减少，我不认为自增自减运算符还有什么太大的使用价值。而在Python这一根本不存在传统for循环的语言中，自增和自减运算符就更没有存在的必要了。

    此外，自增自减运算的效率并不一定很高。在包含编译器的语言中，几乎一定会存在对自增自减操作的编译期优化，事实上`a = a + 1`相比于`a++`效率不会有任何降低，`a = a + 1`这段代码运行时并不会实际涉及两次取址操作，因为编译器会对其进行优化，仅进行一次取址操作，更何况当前主流的静态语言几乎都支持JIT技术，即使是foreach循环也不会相比于传统for循环更慢。就算是对于动态语言来说，JIT优化也是在大规模应用的，例如JavaScript主流的实现引擎全部大量使用了JIT技术进行优化，`a = a + 1`根本不会慢于`a++`，连Python也有PyPy可以进行JIT优化。

    此外，`a++`与`a += 1`本质上没有任何区别，并且即使在不考虑优化的情况下它们显然也不会存在性能上的显著差异，更何况对于这两个都仅仅只涉及一次取址的语句，编译器要将它们优化到一个速度相当简单，没有多大难度。在已经提供了`+=`和`-=`运算符的情况下，从性能上来说，`++`和`--`运算符的提供是没有必要的。

2. 下面程序段的功能是什么？
   
    ```java
    int a[];
    int i, x, y;
    a = new int[10];
    for (i = 0; i < 10; i++) {
        a[i] = (int) (Math.random() * 101);
        System.out.print(a[i] + " ");
    }
    System.out.println();
    x = y = a[0];
    for (i = 1; i < 10; i++) {
        x = (x + a[i] - Math.abs(x - a[i])) / 2;
        y = (y + a[i] + Math.abs(y - a[i])) / 2;
    }
    System.out.println(x + " " + y);
    ```

    **解析**：生成一个包含10个0至100的随机整数的数组，打印这个数组，并输出数组中的最小值(x)和最大值(y)。

    代码逻辑如下：x、y初始时为数组的第一个元素，从第二个元素开始遍历。当x大于当前元素时，`x=(x+a[i]-(x-a[i]))/2`即`a[i]`，否则`x=(x+a[i]+(x-a[i]))/2`即x，因此x即为最小值；y同理，为最大值。


## 作业7
1. 对于某高级语言，公司甲设计的编译程序，按常规让 int 型的变量占 4 个字节，long型的变量占 8 个字节，而公司乙设计的编译程序，却让 int 型和 long 型的变量都占 8 个字节。
   
    张三所在的单位用的是乙设计的编译程序。张三在用该语言编写程序时，把本该声明为long 型的变量都声明为 int 型的变量。
    
    张三这样做好不好？为什么？
    
    **答**：显然不好。事实上C++就深受其害，因为在C/C++里int和long等类型占用的字节数就是会根据平台不同而变化的，C/C++编译的程序可移植性较差很大一部分就是由于这个原因，而size_t类型的产生很大一部分也是出于这个原因。
    
    Java设计之初对所有类型所占的字节进行了统一，然而这在当时引起了很大的争论，因为统一类型所占字节无疑会在某些平台上其二进制会在底层被截断，而这“多余”的截断显然会导致性能降低。实际上这在当时几乎是不可接受的，因为当时压榨计算机的每一分性能几乎是所有人的共识，而这种显然会降低性能的设计在当时不少人看来糟糕至极，人们为此争论了数年才勉强接受这一设计，甚至有一段时间Java几乎也要向C++看齐放弃所有类型固定所占字节了。好在Java最终坚持了这一设计，显然在如今看来这一设计带来了远比其坏处多得多的好处。Java在上世纪末还被认为是“运行速度极慢的语言”，在不少程序员看来慢到无法接受，然而在现在看来，Java甚至已经成为了性能最高的那一批语言之一。
    
    话题也许有些扯远了。上面这段话是为了论证同样的代码在不同平台上表现不一致会造成多么严重的弊端。而题中的单位甚至修改了编译器的默认行为，这造成的问题远比现在C/C++的问题还大，应该坚决禁止。
    
    显然，在单位的糟糕决策已经无法更改的情况下，为了使得自己的代码能够在其他环境下也能正常运行，张三应当正常地将本应该声明为long型的变量依然声明为long型，否则在其他环境下很容易编译不通过，造成可移植性的严重降低，甚至出现无法察觉的隐形BUG，而这种BUG要找到都不容易，修起来要消耗的精力就更是要花比写代码时十倍百倍的精力了。为了少写一个字母而埋下如此巨大的隐患，这毫不值得。
    
    好在，当前除了C/C++以外几乎没有任何主流语言还存在这种不一致性了。

2. 下面程序段的功能是什么？

    ```java
    int a[] = { 2, 6, 6, 9, 13, 18, 23, 23, 23, 23, 23, 28, 28, 28, 30 };
    int i, n = 1;
    for (i = 1; i < 15; i++)
        if (a[i] == a[i - n])
            n++;
    System.out.println(n);
    ```

    **解析**：求解数组中最多的连续重复数字有多少个（题示代码结果为5）。
    
    代码逻辑如下：$$n$$表示当前最大的连续重复数字个数（初始时为1）。遍历数组整型数组a，判断当前元素的前$$n$$个元素是否与当前元素相等，若相等，说明出现了更长的连续重复数字的序列，且长度为$$n+1$$，因此使用`n++`更新$$n$$。
    
    非常巧妙的逻辑。


## 作业8
1. 有一个语法正确的算术表达式，不存在除以$$0$$等无法计算的情况，原始数据、中间结果和最后结果都是int型的。经测算，最后结果在允许的取值范围内，但有的中间结果却不在允许的取值范围内。请问计算机能求出正确结果吗？

   **答**：不能。下面以Java演示（JShell环境）：

   ```java
   jshell> 2 * 1_000_000_000
   $1 ==> 2000000000
   
   jshell> 2 * 10_000_000_000
   |  错误:
   |  整数太大
   |  2 * 10_000_000_000
   |      ^
   
   jshell> 2 * 10_000_000_000 / 10_000_000_000
   |  错误:
   |  整数太大
   |  2 * 10_000_000_000 / 10_000_000_000
   |      ^
   |  错误:
   |  整数太大
   |  2 * 10_000_000_000 / 10_000_000_000
   |                       ^
   ```

   可以看到，尽管`2 * 10_000_000_000 / 10_000_000_000`的结果仍然为$$2$$，并没有超出int类型的大小限制，但由于中间结果`2 * 10_000_000_000`大于int类型能存储的最大整数$$4294967296(2^{32})$$，因此仍发生报错。

   几乎在任何限制整型大小的语言中，都有这个问题，例如下面使用JavaScript演示（Node.js REPL）：

   ```javascript
   > 2 * 1e307
   2e307
   > 2 * 1e308
   Infinity
   > 2 * 1e308 / 1e308
   Infinity
   ```

   可以看到，当中间结果超过了JavaScript支持的最大数字$$1.7976931348623157e+308$$时，其结果为Infinity，而Infinity除以一个非Infinity的整数结果仍是Infinity，不能得到正确结果。

   LISP同理（Chez Scheme REPL）：

   ```scheme
   > (* 2 1e307)
   2e307
   > (* 2 1e308)
   +inf.0
   > (/ (* 2 1e308) 1e308)
   +inf.0
   ```

   即使专用于科学计算的Julia，也存在同样的问题（Julia REPL）：

   ```julia
   julia> 2 * 1e307
   2.0e307
   
   julia> 2 * 1e308
   Inf
   
   julia> 2 * 1e308 / 1e308
   Inf
   ```

   甚至是Python：

   ```python
   >>> 2 * 1e307
   2e+307
   >>> 2 * 1e308
   inf
   >>> 2 * 1e308 / 1e308
   inf
   ```

   为什么会出现这样的情况？因为在几乎所有语言中（当然，在某些极其小众的语言中，存在例外，但不在这里的讨论范围内），表达式求值都遵循特定的顺序。对于上面的`2 * 1e308 / 1e308`，一般都是从左到右进行求值，依次求出结果存至栈中（对于不将整数类型作为基本类型的语言，存放至堆中）并继续运算，在这个例子里，中间结果仍是整型，因此存放中间结果时就会发生溢出，产生错误或是求出Infinity，自然后面运算得到的结果也不再准确。

2. 下面程序段的执行结果是什么？

   ```java
   int a[][];
   int n, i, j, k;
   a = new int[5][5];
   n = 1;
   for (i = 1; i <= 4; i++) {
       k = i;
       for (j = 1; j <= i; j++) {
           a[k][j] = n;
           n++;
           k--;
       }
   }
   for (i = 1; i <= 4; i++) {
       for (j = 1; j <= 5 - i; j++)
           System.out.printf("%3d", a[i][j]);
       System.out.println();
   }
   ```

   **结果**：

   ```
   1  3  6 10
   2  5  9
   4  8
   7
   ```
   
   **解析**：这段代码输出一个斜向的数字金字塔，从1开始依次递增。可以观察到，每一斜行的数字个数依次为1、2、3、4，呈递增关系，因此以递增的i控制；而每次都会往右上角移动，因此以k控制行数，j控制列数，k每次初始化为i，j每次初始化为1，每次`k--`而`j++`，因此向右上移动。n为实际填充进金字塔的数字，从1开始依次递增。因此上面这段代码能够输出如上所示的数字金字塔。


## 作业9

1. Python语言作者设计了for和while两种循环语句。而Pascal语言作者设计了for、while和repeat-until三种循环语句，C语言作者设计了for、while和do-while三种循环语句。与while语句相比，repeat-until和do-while语句使用起来是有些风险的，可为什么还要引入呢？

   **答**：从最初的设计思路来说，do-while语句尽管使用场景有限，但因其特殊性有其存在意义。对于while语句来说，`while (condition) {}`很容易改写成`for (; condition; ) {}`，没什么区别，在这里for更近似一种语法糖。而do-while语句无论是使用while语句还是for语句实现都会存在别扭之处，需要使用一个判断变量，例如do-while改写成for循环需要写成`for (bool b = true; b; b = condition) {}`，而这种需求是客观存在的（尽管不一定多），例如文件读取，无论如何都需要先读取才能判断是否EOF。

   另一点是，do-while实质上是最符合汇编代码的。汇编语言中实际上不存在循环体，仅存在goto语句跳转。那么若要实现while，就需要使用下面三行汇编语句：

   ```c
   goto 4 if condition
   body
   goto 1
   ...
   ```

   而实现do-while仅需两行：

   ```c
   body
   goto 1 if condition
   ...
   ```

   因此理论上来说，如果将一些while语句改写成do-while，是有可能提高程序执行效率的，do-while也是最符合汇编思路的。但实际上这样改写能提高的效率微乎其微……

   不过目前看来，C/C++中do-while最大的作用实际在于宏定义，像是`do { ... } while (0)`（注意不加分号）被广泛应用，大概D.M.Ritchie当初也没想过会有人这么做……例如下面是一段Redis的源码：

   ```c
   #define update_zmalloc_stat_alloc(__n) do { \
      size_t _n = (__n); \
      if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
      if (zmalloc_thread_safe) { \
        update_zmalloc_stat_add(_n); \
      } else { \
        used_memory += _n; \
      } \
    } while(0)
   ```

   然后调用时只需要这样：

   ```c
   update_zmalloc_stat_alloc(3);
   ```

   这甚至很难说是“奇淫巧计”，因为使用`do { ... } while (0)`的宏定义已经在C/C++中被过于广泛地使用。甚至在很多项目中，这成为了do-while存在的唯一意义。

     另一点需要指出的是，Python和Pascal中的for循环与C/C++/Java/C#/JS中的for循环是两码事，而Python中的for循环与Pascal中的for循环实际上也存在较大区别（尽管语法有一些相似）。C语言（以及其一切后代）中的for循环是纯粹的语法糖，除此之外与while没有任何区别；Pascal中的for循环实际上也是语法糖，只是将变量定义与递增写在了一行里（`for i := 1 to 10 do (step 1) …`），在循环体中是可以修改控制变量的。

   然而在Python中，for循环是纯粹的迭代器遍历，`for i in range(5)`实际上不是使i依次递增，而是使i在(0, 1, 2, 3, 4)中依次取值，因此即使在循环体中修改了i的值，也不会影响i的值变化。

   在许多其它语言中，Python的for循环被称为for-each语句，例如C#中直接提供了foreach关键字用于实现类似的迭代功能，Java提供了`for (int x: arr)`语句实现迭代，JS使用`for (const x of arr)`实现迭代。在这些语言的for-each语句中，即使在循环体中修改了i的值自然也不会影响i值的变化，这理所当然，毕竟这是迭代器遍历。当然，不建议在循环中修改控制变量的值，即使在for-each语句中。

   有趣的是，在几乎所有新出现的（主流）语言中，for-each的地位都被极大重视，且设计者试图尽可能使用for-each语句取代传统for语句的作用（指C语言的for语句），即使是被设计用于底层与高性能开发的Rust也采用了`for i in 1..5`这样的写法。显然易见，for-each语句的迭代思路实际上更符合人类思维（不用再关心索引），也使得程序抽象程度进一步提高，对底层的涉及进一步减少，在多数情况下有利于降低心智负担，这是有利于开发的。

   那么，迭代器不会产生执行效率降低的问题吗？当然会。事实上在早期，使用`for (int i: arr)`语句遍历数组与使用传统的`for (int i = 0; i < arr.length; i++)`相比效率仅有后者的一半（甚至不到一半）。当然，这是在for循环体内仅有简单整数计算的情况下，如果for循环内有其他更耗时的计算任务，那么迭代器产生的效率降低就可以忽略不计了。

   然而如果在现在进行类似的测试，会发现for-each语句在Java中几乎没有效率降低，甚至还要略快，这是因为现代编译器针对for-each语句进行了大量编译器优化，这里就不详细展开了。另一点是即使在性能敏感的场景下，for-each带来的些许效率降低也几乎毫无影响，除非涉及到引擎开发与编译器开发这样极端性能敏感的场景，否则for-each语句从不会也不该成为性能瓶颈，更何况对于简单计数型for-each循环，编译器都足够聪明到可以进行合适的优化，这就更不成问题了。

   话题扯远了。或许do-while语句最初的设计也有同样的考虑，它表面上是让程序员在某些少见的场景下能少写一行判断，（有可能的）稍微提高了程序运行效率，但背后的目的是让程序在这样的少见情况下也尽可能保持简洁优雅，提高其可读性。

2. 说出下列E类中【代码1】~【代码3】的输出结果。

   ```java
   class Fish {
       int weight = 1;
   }
   class Lake {
       Fish fish;
       void setFish(Fish s) {
           fish = s;
       }
       void foodFish(int m) {
           fish.weight = fish.weight + m;
       }
   }
   public class E {
       public static void main(String[] args) {
           Fish redFish = new Fish();
           System.out.println(redFish.weight);    //【代码1】
           Lake lake = new Lake();
           lake.setFish(redFish);
           lake.foodFish(120);
           System.out.println(redFish.weight);    //【代码2】
           System.out.println(lake.fish.weight);  //【代码3】
       }
   }
   ```

   **结果**：

   ```
   1
   121
   121
   ```

3. 请说出A类中System.out.println的输出结果。

   ```java
   class B {
       int x = 100, y = 200;
       public void setX(int x) {
           x = x;
       }
       public void setY(int y) {
           this.y = y;
       }
       public int getXYSum() {
           return x + y;
       }
   }
   public class A {
       public static void main(String[] args) {
           B b = new B();
           b.setX(-100);
           b.setY(-200);
           System.out.println("sum=" + b.getXYSum());
       }
   }
   ```

   **结果**：

   ```
   -100
   ```

   **解析**：由于`B.setX`中使用的不是`this.x = x`，`setX`实际上无法修改实例变量x的值，因此x仍为$$100$$，则`b.getXYSum()`的结果为$$100 - 200 = -100$$.

4. 请说出A类中`System.out.println`的输出结果。

   ```java
   class B {
       int n;
       static int sum = 0;
       void setN(int n) {
           this.n = n;
       }
       int getSum() {
           for (int i = 0; i <= n; i++) {
               sum += i;
           }
           return sum;
       }
   }
   public class A {
       public static void main(String[] args) {
           B b1 = new B(), b2 = new B();
           b1.setN(3);
           b2.setN(5);
           int s1 = b1.getSum();
           int s2 = b2.getSum();
           System.out.println(s1 + s2);
       }
   }
   ```

   **结果**：

   ```
   27
   ```

   **解析**：$$s1 = 1 + 2 + 3 = 6$$, $$s2 = 6 + 1 + 2 + 3 + 4 + 5 = 21$$, $$s1 + s2 = 27$$.


## 作业10

1. 为什么Java语言作者让类的成员变量有默认值，而让方法的局部变量没有默认值？

   **答**：需要指出的是，这里的题目存在一些描述不太严谨的地方。事实上，Java中只有当类的字段为基本类型时才会拥有默认值，引用类型则会被赋予null，当然，null或许也可以被认为是一种默认值。在Java中，基本类型仅包含boolean、char、byte、short、int、long、float、double。

   这实际上是一个非常难以回答的问题。固然可以简单地回答这是为了“确保成员变量一定被初始化，以减少BUG”，但为什么要赋予默认值？未赋值引用时像局部变量一样报错，不是一样可以吗？

   在Bruce Eckel的***《On Java 8》（中文版第38页）***中，我找到的相关描述指出：

   > 这一特点确保了基本类型的字段一定会被初始化（而C++就不会这么做），并且从源头减少了许多不应该出现的BUG。只不过对于你编写的程序而言，这些默认值可能并不是正确或合理的值，所以最佳实践应该是你显式地初始化这些变量。

   然而这似乎并没有解决问题。即使在这一上下卷加起来超一千页的巨著中，我也没有找到这个令人困惑的问题的答案。

   后来我尝试在Stack Overflow上搜索相关问题，也仅得到了寥寥数个答案，其中一个这么说（已翻译成中文）：

   > 所有成员变量都将被加载进堆中，因此在类实例化时需要有默认值。对于局部变量来说，它们会在栈中存储直到被使用（先不谈Java 7开始的内存优化，那是另一个话题了），因此我们需要显式初始化它们。

   说实话，我觉得这没有回答任何问题。为什么在堆区分配内存就一定需要默认值？即使确实在实现中分配了默认值，Java也可以实际上要求必须在构造器中进行初始化，或是要求必须在使用前进行初始化。或者，Java也可以考虑在缓冲区先存放未初始化的成员变量，然后将其分配到堆区。

   我找遍全网，似乎都没有回答能够完整地解释这一问题。我试图从内存分配的角度出发，探究Java为什么要这么做，也没有找到合适的答案。

   在我的思考中，有一种可能或许是成立的，但这听起来稍微有些匪夷所思。众所周知的一点是Java在嵌套类上下了很大的功夫，而实际上内部类实例化时若外部类未实例化，则会将其实例化并保留一个隐式的引用，这是显然的，否则内部类无法访问外部类的成员变量。而如果外部类的成员变量并未实例化，就可能发生危险。

   不过这仍是个不成熟的想法，因为Java事实上可以通过编译器分析成员变量是否在实例化前被引用，这和上面其实是一个问题。我的怀疑是在这种复杂的情况下编译器的工作将变得非常复杂，如果再考虑到用户可能使用的诸如对象克隆、构造器复制等操作，情况将变得更为复杂，这可能会大幅降低编译效率，并导致大量潜在的BUG。而Java似乎不愿意让用户在构造器中将成员变量全部手动初始化（而很多语言如TypeScript都要求在构造器中将全部成员变量初始化），因此采用了为成员变量赋默认值的操作。

   简单来说，由于在Java中类的实例化场景非常广，很难确定具体将在什么时候进行类初始化（对于异步操作来说更是如此），因此Java为成员变量赋予默认值以避免潜在的BUG。这个问题在各类语言中有两种常见的解决方式：默认值或要求在构造器中初始化。Java选择了前者。理论上来说，Java编译器应当可以跟踪类实例化的位置来阻止成员变量在赋值前引用，但这或许会造成过大的编译开销，因此Java选择了更为简单的方式。

   而在C++中，情况就完全不同了，C++在成员变量未初始化时不会报错，只会发出警告，那么成员变量所在的堆区究竟是什么值，就很难说清楚了。毕竟在堆区为变量赋初值会造成$$O(n)$$的时间开销，而效率至上的C++无法容忍这一问题，因此选择将自由交给程序员。

   这似乎是我能想到的唯一一个解释。至于具体是什么原因，或许得去问问Java最初的设计者们是怎么样想的。

2. 请说出E类中【代码1】和【代码2】的输出结果。

   ```java
   class A {
       double f(int x, double y) {
           return x + y;
       }
       int f(int x, int y) {
           return x * y;
       }
   }
   public class E {
       public static void main(String[] args) {
           A a = new A();
           System.out.println(a.f(1, 2.0));
           System.out.println(a.f(1, 2));
       }
   }
   ```

   **结果**：

   ```
   3.0
   2
   ```

3. 上机执行下列程序，了解可变参数。

   ```java
   public class E {
       public static void main(String[] args) {
           f(1, 2);
           f(-1, -2, -3, -4);
           f(9, 7, 6);
       }
       public static void f(int... x) {
           for (int i = 0; i < x.length; i++) {
               System.out.println(x[i]);
           }
       }
   }
   ```

   **结果**：

   ```
   1
   2
   -1
   -2
   -3
   -4
   9
   7
   6
   ```

4. 类的字节码进入内存时，类中的静态块会立刻被执行。执行下列程序，了解静态块。

   ```java
   class AAA {
       static { // 静态块
           System.out.println("我是AAA中的静态块!");
       }
   }
   public class E {
       static { // 静态块
           System.out.println("我是最先被执行的静态块!");
       }
       public static void main(String[] args) {
           AAA a = new AAA(); // AAA的字节码进入内存
           System.out.println("我在了解静态(static)块!");
       }
   }
   ```

   **结果**：

   ```
   我是最先被执行的静态块!
   我是AAA中的静态块!
   我在了解静态(static)块!
   ```

   **解析**：事实上，Java类完整的初始化顺序比较复杂：①首先初始化静态变量和静态代码块（仅在类第一次实例化时被执行）；②初始化实例属性和运行直接写在类结构体中的代码块（即实例初始化）；③执行构造器。

   在上面的代码中，创建了static静态代码块，它仅会在类第一次实例化时加载，并且先于实例属性和构造器的初始化。

## 作业11

1. 在Java语言中，类的成员变量分为实例变量和类变量，实际上它们都是“类的”变量。你能给实例变量和类变量分别取个更恰当的名字吗？同样，你能给实例方法和类方法分别取个更恰当的名字吗？

   **答**：需要指出的是，“实例变量”并不是“类的”变量，它是“类的实例”的变量，一个是类，一个是对象。在Java中，是不能直接通过类名引用非静态变量的。

   在主流的，使用class-based方式的面向对象语言中，“类”是一个模板，创建实例时从模板“复制”这个类并进行实例初始化（事实上类有自己的方法区，多个实例共享同一个类，只是发生了引用复制）。类本身拥有的变量叫做“类变量”或称“静态变量”，在Java中这两者没有区分，不过在Python中有微妙的区别，这里不展开。这个名字本身应当没有什么问题，看起来非常清晰。

   “实例变量”为类实例所拥有的变量，用来保存实例状态，也称“成员变量”甚至“对象变量”（这种说法很少有人使用）。实例是一个具体的对象而非模板，它有其状态与生命周期。事实上实例确实可以引用类变量，而类则不能引用实例变量。这在初学时似乎有些令人困惑，但了解了整个机制后实际上非常简单，我同样不认为“实例变量”有什么不妥。

   同理，实例方法和类方法也一样。它们的根本区别在于实例方法需要隐式传入一个对实例对象本身的引用，而类方法传入一个对类本身的引用。事实上虽然说Java中实例方法的定义不需要像Python一样在前面加个`self`，但JVM的确会隐式传入`this`，而且在hotspot的实现中也是将其作为第一个参数，也就是说定义实例方法时其实隐式地定义了第一个参数为`this`，而`obj.f(a1, a2)`实际上等同于`f(obj, a1, a2)`，只是在Java中没有直接将这些底层机制暴露出来。类方法同理，`cls.f(a1, a2)`实际上等价于`f(cls, a1, a2)`。

   也就是说实例方法和类方法本质上应当不存在区别，它们都是单纯的函数，只不过实例方法中传入了对象引用作为第一个参数，而类方法传入了类引用作为第一个参数，它们都是特殊的函数（尽管在完全面向对象的Java中，并不存在真正的函数）。

   如果一定要给类属性/方法和实例属性/方法换个名字的话，我倾向于换成“共享属性/方法”和“独立属性/方法”。但老实说，虽然这可能会给初学者带来更少的困惑，但反而会产生极大的误导性，改了名字之后并没有比原来的名字更好。

2. 请说出E类中【代码1】和【代码2】的输出结果。

   ```java
   class A {
       double f(double x, double y) {
           return x + y;
       }
   }
   class B extends A {
       double f(int x, int y) {
           return x + y;
       }
   }
   public class E {
       public static void main(String[] args) {
           B b = new B();
           System.out.println(b.f(3, 5));     // 【代码1】
           System.out.println(b.f(3.0, 5.0)); // 【代码2】
       }
   }
   ```

   **结果**：

   ```
   8.0
   8.0
   ```

   **解析**：**代码1**处调用了`B.f`，**代码2**中调用了`A.f`，不过这里的返回值由于都是`x + y`且返回值都是double类型，因此并没有体现。

3. 请说出E类中【代码1】和【代码2】的输出结果。

   ```java
   class A {
       public int getNumber(int a) {
           return a + 1;
       }
   }
   class B extends A {
       public int getNumber(int a) {
           return a + 100;
       }
       public static void main(String[] args) {
           A a = new A();
           System.out.println(a.getNumber(10));  //【代码1】
           a = new B();
           System.out.println(a.getNumber(10));  //【代码2】
       }
   }
   ```

   **结果**：

   ```
   11
   110
   ```

   **解析**：这题没什么值得困惑的地方，只是单纯的继承与向上转型方面知识的考察而已。唯一值得一提的只有`a = new B()`一句，这句话没有报类型错误是因为B为A的子类，可以向上转型为A，而a的类型为A，因此自然不会报错。


## 作业12

1. 某同学在学习Java语言程序设计课程时，想弄清楚没有成员变量的类的对象到底是不是不占用空间的“皮包公司”。你能为这位同学出谋划策吗？

   **答**：对象当然是占用空间的，否则Java中也不会出现int和Integer、double和Double这类基本类型和包装类型的区分，其目的就是为了减少对象带来的运行效率的缩减。

   先不谈内部类等复杂情况，现在集中于一个单纯的空对象：

   ```java
   class Foo {}
   Foo foo = new Foo();
   ```

   显然，上面的代码创建了一个既无成员变量也无成员方法的空类Foo，然后创建了它的对象foo。看起来，foo显然是一个完完全全的空对象。

   然而，即使稍作考虑，也应该能意识到该对象不可能在内存中“不占用空间”。这是由于Java必须处理继承关系，为此就需要记录该对象的类信息。同时，任何对象都有`.getClass()`方法可以获得其类名。显然，这需要对象在存储的过程中存储其所在类元数据的指针。

   以最主流的Java虚拟机实现Hotspot为例（64位下），非数组对象实例的对象头占16字节（未开启指针压缩的情况下），其中8字节为MarkWord(\_mark)，8字节为KlassWord(\_klass)（开启指针压缩后为4字节），而\_klass属性就是用于存储类元数据指针的，这符合我们之前的猜测。

   那么，MarkWord又包含哪些信息呢？这主要与Java多线程有关。MarkWord标记了对象的加锁状态（无锁、偏向锁等，锁的类别由标记位区分），对于无锁和偏向锁对象，还会包含一个占用4bit的age信息，即对象年龄，这与Java的垃圾回收机制有关，这里就不详细展开了。

   因此，即使对于上面创建的空对象foo，在64位虚拟机下也需要占用16字节内存（开启指针压缩后为12字节），这部分是所有对象必须的对象头所占用的空间。Java中任何对象在Hotspot 64位虚拟机下至少占用12字节，若为数组对象，其对象头还包含_length属性，需要额外再占用4字节。至于含有其他成员变量和方法的对象，那自然会需要占用更多空间。

   这显然也是为什么Java会存在所谓“基本类型”，如int、float、double等。若只需存储一个单纯的整型变量，占用至少12字节的空间利用率未免有些过低了，且创建对象需要在堆区分配内存，无法有效利用栈区，这会大大拖累程序的运行效率。当然，现在看来，Java中的“基本类型”带来的问题远大于其提升的运行效率，这方面“基本类型”和当年使用类型擦除模拟“伪泛型”的决定得各背一半锅，这就是题外话了。

2. 请说出E类中【代码1】~【代码4】的输出结果。

   ```java
   class A {
       double f(double x, double y) {
           return x + y;
       }
       static int g(int n) {
           return n * n;
       }
   }
   class B extends A {
       double f(double x, double y) {
           double m = super.f(x, y);
           return m + x * y;
       }
       static int g(int n) {
           int m = A.g(n);
           return m + n;
       }
   }
   public class E {
       public static void main(String[] args) {
           B b = new B();
           System.out.println(b.f(10.0, 8.0)); //【代码1】
           System.out.println(b.g(3));         //【代码2】
           A a = new B();
           System.out.println(a.f(10.0, 8.0)); //【代码3】
           System.out.println(a.g(3));         //【代码4】
       }
   }
   ```

   **结果**：

   ```
   98.0
   12
   98.0
   9
   ```

   **解析**：这里实际上涉及了向上转型的问题。调用类方法时，上面的`b.g`、`a.g`相当于`B.g`、`A.g`，实质上是调用了类型中的类方法，因此a调用的是A中的g而非B中的g；而调用实例方法时，调用的是实例上存在的方法，尽管a被赋以A类型，但实际上只限制了a只能使用A中规定**签名**的方法，对方法的覆写与重载则并没有限制，因此这里仍然调用了`B.f`而非`A.f`。道理很清楚，类方法属于类本身，调用时自然是从类调用而非通过实例获取其类型然后调用其类方法，而实例方法属于实例，因此自然是从实例本身调用，没有太多值得困惑的地方。

3. 请说出E类中【代码1】~【代码3】的输出结果。

   ```java
   class A {
       int m;
       int getM() {
           return m;
       }
       int seeM() {
           return m;
       }
   }
   class B extends A {
       int m;
       int getM() {
           return m + 100;
       }
   }
   public class test {
       public static void main(String[] args) {
           B b = new B();
           b.m = 20;
           System.out.println(b.getM());  //【代码1】
           A a = b;
           a.m = -100;                    // 上转型对象访问的是被隐藏的m
           System.out.println(a.getM());  //【代码2】上转型对象调用一定是
                                          // 子类重写的getM()方法
           System.out.println(a.seeM());  //【代码3】子类继承的seeM()方法
                                          // 操作的m是被子类隐藏的m
       }
   }
   ```

   **结果**：

   ```
   120
   120
   -100
   ```
